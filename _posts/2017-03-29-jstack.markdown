---
layout: post
title:  使用jstack分析CPU占用过高的java线程
date: 2017-03-29
---

最近做了一个需求，需求转测试后发现对应服务的CPU占用率高达百分之一百多。为了避免版本发布到现网生产环境后出事故，就赶紧定位了下。
本来在公司写好了关于整个分析过程的博客，但由于公司安全限制，无法发到外网，所以我只能回家后再写一遍，这一遍无法贴上真实的图片(只能从网上盗图)。
分析过程大致如下：

#### 1. 通过top命令找到占用CPU最高的进程
![top命令查看CPU占用情况]({{ site.url }}images/17-3-29/top_cmd.png)
从上图可以看出PID（进程号）为28555的进程占用CPU高达200%。

#### 2. 通过ps命令查找进程内占用CPU最高的线程
![ps命令查找进程内各线程占用CPU情况]({{ site.url }}images/17-3-29/ps_cmd.png)

从上图可以看出TID（线程号）为28802的线程占用了60.4%的CPU。
其实命令完全可以改为：
```
#该命令会对进程内各线程使用的CPU情况做个排序，最上边的就是占用CPU最高的线程
ps -mp 28555 -o THREAD,tid,time|sort -rn 
```

#### 3. 将对应的TID转换为16进制格式（仅限JDK1.7及以下）
在上一步，我们找到了耗CPU最高的线程28802，但我们需要将这个线程号转换成16进制后才能在堆栈中找到相应的信息。
转换命令如下：
```
printf "%x\n" TID
```
![TID转换]({{ site.url }}images/17-3-29/convert_tid.png)

#### 4. 通过jstack查看线程堆栈
在JDK的bin目录下执行如下命令:
```
./jstack -F PID|grep TID -A lines
```
注意：如果之前已将JDK路径导入环境变量，则此处无需再到JDK的bin路径下去执行命令。其中
PID需要替换成进程号，TID需替换为步骤3中得到的线程号（若使用的是JDK1.8，则直接替换为10进制的），
lines需替换为你想在屏幕打印出的堆栈行数。

![TID转换]({{ site.url }}images/17-3-29/jstack.png)

#### 5. 找到相应的代码进行分析
从线程堆栈中已经可以看出调用关系，以及出问题的代码逻辑大概的位置，此时只需要找到源码分析即可。一个应用占用CPU很高，除了确实是计算密集型应用之外，通常原因都是出现了死循环。

参考链接：
http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html